// The whole file must either succeed or fail
root = {
    SOI
  ~ model_entry*
  // Expect the data keyword before the data section starts
  // (Inserted automatically in Rust if not present)
  ~ ("data;"+ ~ data_entry*)?
  ~ EOI
}

// //////////////////////
// MODEL
// GMPL can be split into .mod model files and .dat data files
// The bulk of this grammar deals with the former
// The root level entries are capitalised to make scanning a bit easier,
// it doesn't have any other significance.
// //////////////////////
model_entry = _{
  // Main model entries
  | VAR
  | PARAM
  | SET
  | OBJECTIVE
  | CONSTRAINT
  // Below here are ignored
  | FOR
  | TABLE
  | PRINT
  | CHECK
  | SOLVE
  | END
}

// Variable
// Example: var Demand >= 0;
VAR        = { "var" ~ name ~ domain? ~ var_bounds? ~ ("," ~ param_type)? ~ ";" }
var_bounds = { rel_op ~ number }

// Parameter
// The comma separator seems to be optional
// Example: param Discount{r in REGION} := (1 + DiscountRate[r])
PARAM           =  { "param" ~ name ~ domain? ~ (","? ~ param_attrib)* ~ param_assign? ~ ";" }
param_attrib    = _{ param_type | param_condition | param_in | param_default }
param_type      =  { "integer" | "binary" | "symbolic" }
param_condition =  { rel_op ~ expr }
param_in        =  { "in" ~ expr }
param_assign    =  { ":=" ~ expr }
// string_literal here is only used for output path
param_default   =  { "default" ~ (expr | string_literal) }

// Set
// Example: set DAILYTIMEBRACKET;
SET             =  { "set" ~ id ~ set_domain? ~ set_condition? ~ (":=" ~ set_expr)? ~ ";" }
// unlike `domain`, this doesn't allow a condition, and the "f in" part is optional
set_domain      =  { "{" ~ (set_domain_part ~ ","?)+ ~ "}" }
set_domain_part =  { (id ~ "in")? ~ domain_set }
set_condition   =  { "within" ~ within_set ~ ("cross" ~ cross_set)? }
within_set      = @{ id }
cross_set       = @{ id }
set_expr        =  { domain | set_math }
set_math        =  { var_subscripted ~ ("inter" ~ var_subscripted)+ }

// Constraint
// Example: s.t. Capacity{r in REGION}: NewCap[r] = 2
// Apparently multiple expressions are supported?
// Osemosys doesn't use this
CONSTRAINT      =  { constraint_kw ~ name ~ domain? ~ ":" ~ constraint_expr ~ ";" }
constraint_expr =  { expr ~ rel_op ~ expr }
constraint_kw   = _{ "subject to" | "subj to" | "s.t." } // can be omitted

// Objective
// Example: minimize cost: sum{y in YEAR} Cost[y];
OBJECTIVE = { obj_sense ~ id ~ ":" ~ expr ~ ";" }
obj_sense = { "maximize" | "minimize" }


// For (ignored)
FOR       = { "for" ~ domain ~ "{" ~ for_inner* ~ "}" }
for_inner = { FOR | PRINT }

// Print (ignored)
PRINT = @{ "printf" ~ (!NEWLINE ~ !";" ~ ANY)* ~ ";" }

// Check (ignored)
CHECK = @{ "check" ~ (!NEWLINE ~ !";" ~ ANY)* ~ ";" }

// Solve (ignored)
SOLVE = { "solve" ~ ";" }

// End (ignored)
END = { "end" ~ ";" }

// Table (ignored)
TABLE      = { "table" ~ id ~ domain? ~ table_out ~ table_path ~ table_vars ~ ";" }
table_out  = { "OUT" ~ string_literal }
table_path = { "ResultsPath" ~ "&" ~ string_literal }
table_vars = { ":" ~ table_var ~ ("," ~ table_var)* }
table_var  = { var_subscripted ~ "~" ~ var_subscripted }

// //////////////////////
// DATA FILES
// Generally a separate .dat file.
// Mostly param values.
// Less of the grammar but will be far majority of text parsed.
// //////////////////////
data_entry = _{
  | DATA_SET
  | DATA_PARAM
  | END
}

// Data: Set
DATA_SET   = { "set" ~ id ~ set_index? ~ (":=" ~ set_assign?)? ~ ";" }
set_assign = { set_vals | set_tuples }
set_tuples = { set_tuple+ }
set_tuple  = { "(" ~ set_val ~ "," ~ set_val ~ ")" }
set_vals   = { set_val+ }
set_val    = { id | int }
set_index  = { "[" ~ index ~ ("," ~ index)* ~ "]" }

// Data: Param
DATA_PARAM          =  {
    "param" ~ id ~ ("default" ~ param_data_default)? ~ ":="? ~ param_data_body? ~ ";"
}
param_data_default  = @{ number }
param_data_body =      { param_data_scalar | param_data_matrix+ | param_data_list }
// We don't support using "list" format for 2D params
// As there's no way to unambiguously parse in PEST (needs post-processing)
param_data_scalar   = @{ number }
param_data_list     =  { param_data_pair+ }
param_data_pair     =  { set_val ~ number }
param_data_matrix   =  { param_data_target? ~ ":" ~ param_data_cols ~ ":="? ~ param_data_row+ }
param_data_cols     =  { set_val+ }
param_data_row      = ${ set_val ~ param_data_row_vals }
param_data_row_vals = ${ ((" " | "\t")+ ~ param_data_val)+ }
param_data_val      = @{ number }
param_data_target   =  { "[" ~ (index_var | param_data_any) ~ ("," ~ (index_var | param_data_any))* ~ "]" }
param_data_any      =  { "*" }

// //////////////////////
// LANGUAGE COMPONENTS
// //////////////////////

// Domain
// example:
// {r in REG, t in TECH:Capacity[r,t,y]<>0}
domain             =  { "{" ~ (domain_part ~ ","?)+ ~ (":" ~ logic_expr)? ~ "}" }
domain_part        =  { domain_var ~ "in" ~ domain_set ~ subscript? }
domain_var         =  { domain_var_single | domain_var_tuple }
domain_var_single  = @{ id }
domain_var_tuple   = { "(" ~ id ~ ("," ~ id)+ ~ ")" }
domain_set         = @{ id }

// Logical expression
// Expressions that evaluate to true or false
// Uses Pratt parser for proper operator precedence (and > or)
// Example: Demand[r] <> 0
logic_expr     =  { logic_primary ~ (logic_infix ~ logic_primary)* }
logic_primary  = _{ comparison | logic_compound }
logic_infix    = _{ bool_and | bool_or }
comparison     =  { expr ~ rel_op ~ expr }
logic_compound =  { "(" ~ logic_expr ~ ")" }

// Index
var_subscripted =  { var_ref ~ subscript? }
var_ref         = @{ id }
subscript       =  { "[" ~ index ~ ("," ~ index)* ~ "]" }
index           =  { index_var ~ index_shift? }
index_var       = @{ id }
index_shift     =  { ("+" | "-") ~ "1" }

// Expression
// Bundled up with string_literal as often that is also allowed
// Uses Pratt parser for proper operator precedence
// Precedence (lowest to highest): conditional, add/sub, sum/prod, mul/div, neg, pow
// Example: Rate[r] * Ratio[r]
expr            =  { prefix* ~ primary ~ (infix ~ prefix* ~ primary)* }
prefix          = _{ neg | sum_prefix }
neg             =  { "-" }
sum_prefix      =  { "sum" ~ domain }
infix           = _{ add | sub | mul | div | pow }
add             =  { "+" }
sub             =  { "-" }
mul             =  { "*" }
div             =  { "/" }
pow             =  { "^" }
primary         = _{ conditional | number | func | var_subscripted | "(" ~ expr ~ ")" }
conditional     =  { "if" ~ logic_expr ~ "then" ~ expr ~ ("else" ~ expr)? }

// Function
// min/max have special syntax: min{domain} min(var)
// They should technically have the same priority as sum (prefix) but they're never used
// like that so just leaving them as-is
func             = _{ func_min | func_max }
func_min         =  { "min" ~ domain ~ "min" ~ "(" ~ func_var ~ ")" }
func_max         =  { "max" ~ domain ~ "max" ~ "(" ~ func_var ~ ")" }
func_var         = @{ id }
bool_and         =  { "and" | "&&" }
bool_or          =  { "or" | "||" }
rel_op           =  { "<=" | "<>" | "<" | "==" | "=" | ">=" | ">" | "!=" }

// //////////////////////
// GRAMMAR BASICS
// //////////////////////

// Primitives
name       = @{ id }
id         = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
number     = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? }
int        = @{ ASCII_DIGIT+ }

// String literal
string_literal =  { single_quoted | double_quoted }
single_quoted  = _{ "'" ~ single_char* ~ "'" }
single_char    = _{ "''" | (!"'" ~ ANY) }
double_quoted  = _{ "\"" ~ double_char* ~ "\"" }
double_char    = _{ "\"\"" | (!"\"" ~ ANY) }

// Comments and whitespace are automatically inserted between all rules
WHITESPACE       = _{ " " | "\t" | NEWLINE }
COMMENT          = @{ comment_multi | comment_single }
comment_single   = @{ "#" ~ (!NEWLINE ~ ANY)* }
comment_multi    =  { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
